/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.8";  static = false;}/**
 * This defines the main class that is generated by the parser generator.  We've
 * added a main method to the code that will be generated.
**/PARSER_BEGIN(PS7Compiler)package ps7;import java.util.HashMap;
public class PS7Compiler{
  // Maps programming language variables to DC registers  private HashMap < String, Character > variables =
        new HashMap < String, Character > ();
  // Maps programming language variables to types.
  private HashMap<String, String > types =
        new HashMap<String, String >();

  // If the t is not "int", throws a TypeException
  public void checkInt (String type)
  {    if (!(type.equals("int")))
    {      throw new TypeException("Expected int, received " + type);
    }
  }
  
  public void checkBoolInt(String type)
  {	
	if(type.equals("string"))
	{		throw new TypeException("Expected int or boolean, received " + type);
	}
  }
  public void checkBool(String type)  {
    if(!type.equals("boolean"))
    {
      throw new TypeException("Expected boolean, received " + type);
    }  }                
    
    public static void main(String args [])  {    PS7Compiler parser = new PS7Compiler(System.in);    try    {      parser.program();    }
    catch (TypeException e)
    {      System.err.println(e.getMessage());
    }    catch (ParseException e)    {      System.err.println(e.getMessage());    }    catch (TokenMgrError e)    {      System.err.println(e.getMessage());    }
    catch (RuntimeException e)
    {
      System.err.println(e.getMessage());
    }  }}

/**
 * Exception used to report type-checking errors.
 */
 class TypeException extends RuntimeException
 {   public TypeException (String message)
   {     super(message);
   }
 }PARSER_END(PS7Compiler)/************************ Regular expressions that define tokens ***********************/SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* OPERATORS */{  < EQUALS : "=" >| < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >
| < GTHEN : ">" >
| < LTHEN : "<" >
| < CMPEQUALS : "==" >}TOKEN :{
  < INTTYPE : "int" >
| < STRINGTYPE : "string" >
| < BOOLEANTYPE : "boolean" >
| < BOOLEAN: "true" | "false" >| < PRINT : "print" >
| < NEWLINE : "newline" >
| < IF : "if" >
| < ELSE : "else" >| < CONSTANT : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >| < VAR : (< LETTER >)+ >| < #LETTER :    [ "a"-"z" ]  | [ "A"-"Z" ] >
| < STRING: "\"" (~["\"", "[", "]"])* "\"" >
}/***************************** Productions that define grammar *******************/void program() :{
}{
	(
	  anotherStatement()	)*

< EOF >
}
void anotherStatement() :
{	
}
{
  (
    conditionalStatement()  )
|
  (
  	statement()
  )
}

void statement() :{  Token t;
  Token type;
  String etype;  
  
  }{
 (	     	     t = < VAR > (< EQUALS > | < LTHEN > | < GTHEN > ) etype = Exp() ";"     	     	    {	      if (variables.get(t.image) == null)	      {	          throw new TypeException("Undeclared variable: " + t.image);	      }	      	      if (!types.get(t.image).equals(etype))		  {			  throw new TypeException("Type mismatch");	      }				      char reg = variables.get(t.image);	      System.out.println("s" + reg + " ");	      	    }    	  )     
|   (    < PRINT > etype = Exp() ";"    {
      if(etype.equals("boolean"))      {
        System.out.print(" sa [true] la 0 [sa [false]] sa =a ");
      }      System.out.println("n ");    }     )
|
(
  < NEWLINE > ";"
  {	System.out.print("[] n");
  })
}


String conditionalStatement() :
{
  Token t1;
  Token type1;
  String stype;
  String iftype, elsetype, etype1;     
}
{    
(
         < IF > "(" stype = Exp() ")"
			{
				System.out.print("[ ");
				iftype = "";
	        }
	    "{"    
	         ( statement() )*
	    "}"
	        {
			  System.out.println(" ] st");
			}		
         
        < ELSE >
        "{"
	        {
	          System.out.print("[ ");
	        }
	        	( statement() )*
	        {
			  System.out.println(" ] se  ");
			}
		"}"
			  //t - > if true register
			  //e - > else register		  
			  // sm lt lm 0 [sm le] sm =m x		
       
         {
           System.out.println("sm lt lm 0 [sm le] sm =m x");
      		checkBool(stype);
    	 }      
      )
      {
        return "if";
      }
    | (
    (type1= < INTTYPE > | type1= < STRINGTYPE > | type1= < BOOLEANTYPE >)
      t1 = < VAR > < EQUALS > etype1 = Exp() ";"
    {
      if (variables.get(t1.image) == null)
      {
        if (variables.size() >= 26)
        {
          throw new TypeException("Too many variables; limit is 26");
        }
        variables.put(t1.image, (char) ('A' + variables.size()));
		types.put(t1.image, type1.image);

		if (!type1.image.equals(etype1))
		{
		  throw new TypeException("Type mismatch: Expected " + type1+ " instead of "+ etype1);
		}
		
		char reg2 = variables.get(t1.image);
        System.out.println("s" + reg2 + " ");
      }
      else
      {
        throw new TypeException("Variable already declared: " + t1.image);
      }
    }    
  )
  {
    return etype1;
  }   
}


String Exp() :
{
  Token t;
  String type7, type8;
}
{
  type7 = exp()  
  (     
    (
      t = < LTHEN >    
    )
    type8 = exp()
    {
		System.out.print("sa sb 0 la lb [sa 1] sa <a ");		
		checkInt(type7);		
		checkInt(type8);
		return "boolean";
    }
  |     
    (
      t = < GTHEN > 
    )
    type8 = exp()
    {
		System.out.print("sa sb 0 la lb [sa 1] sa >a ");
		checkInt(type7);
		checkInt(type8);
		return "boolean";
    }
  |     
    (
      t = < CMPEQUALS >    
    )
    type8 = exp()
    {
        System.out.print("sa sb 0 la lb [sa 1] sa =a ");
		checkBoolInt(type7);
		checkBoolInt(type8);
		return "boolean";
    }
  )*
  {
    return type7;
  }
}
String exp() :{  Token t;
  String type5, type6;}{  type5 = term()  (    (      t = < PLUS >    | t = < MINUS >        )    type6 = term()    {      System.out.print(t.image + " ");
      checkInt(type5);
	  checkInt(type6);
    }
    )*
  {    return type5;
  }}String term() :{  Token t;
  String type3, type4;}{  type3 = factor()  (    (      t = < MULTIPLY >    | t = < DIVIDE >    )    type4 = factor()    {      System.out.print(t.image + " ");
      checkInt(type3);
      checkInt(type4);    }  )*
  {
    return type3;  }}String factor() :{
  String type2;
}{  "-"    type2 = element()
  {
    checkInt(type2);
    System.out.print("_1 * ");
    return "int";  }
|
	"!"
	type2 = element()
	{	  
	  checkBool(type2);
	  System.out.print(" sa 0 la 0 [sa 1] sa =a");
	  return "boolean";
	}| type2 = element()
  {	return type2;
  }}String element() :{  Token t;
  String type1;}{  t = < CONSTANT >  {    System.out.print(t.image + " ");
    return "int";  }
|
  t = < STRING >
  {
    String dcs = t.image.replaceFirst("\"", "[");
    dcs = dcs.replaceFirst("\"", "]");	System.out.print(dcs);
	return "string";
  }
|
	t = < BOOLEAN >
	{
	  int bool = t.image.equals("true") ? 1 : 0;

	  System.out.print(bool + " ");	  		
	  return "boolean";
	}
|   t = < VAR >  {    Character reg = variables.get(t.image);    if (reg == null)    {      throw new RuntimeException("Undefined variable " + t.image);    }    else    {      System.out.print("l" + reg + " ");      return types.get(t.image);    }  }
| "(" type1 = Exp() ")"
  {	return type1;
  }  }
